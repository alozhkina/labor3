/*************************************************************
	Практическое занятие №3. Встроенные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdlib>
#include <ctime>
#include <string>
#include "vld.h"

#define	  stop __asm nop
using namespace std;
int main()
{

	///////////////////////////////////////////////////////////////
	//			Встроенные массивы                               //
	///////////////////////////////////////////////////////////////

		//Задание 1. Объявите трехмерный N*M*K массив и сформируйте указанные
		//значения элементов следующим образом:
		//а) проинициализируйте массив при объявлении
		//б)* объявите неинициализированный массив и присвойте значения элементам
		//	с помощью кода
		//					 |--------|		
		//				   / |3  3  3 |		
		//    			 |---------|3 |
		//			   / | 2  2  2 |3 |
		//			  |---------|2 |__|
		//			  | 1  1  1 |2 | /
		//			  | 1  1  1 |__| 
		//			  | 1  1  1 | /
		//			  |_________|
		//Средствами отладчика проверьте правильность Вашего решения.
	const int N = 3, M = 3, K = 3;
	int arr[N][M][K] = {
		{{1,1,1},{1,1,1},{1,1,1}},
		{{2,2,2},{2,2,2},{2,2,2}},
		{{3,3,3},{3,3,3},{3,3,3}}
	};
	int a[N][M][K];
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			for (int k = 0; k < K; k++)
			{
				a[i][j][k] = i + 1;
			}
		}
	}
	stop;
	//в) найдите сумму элементов массива
	int s = 0;
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			for (int k = 0; k < K; k++)
			{
				s = s + a[i][j][k];
			}
		}
	}
	std::cout << s << std::endl;//54
	stop;
	//г) проинициализируйте массив при определении:
	//					 |--------|		
	//				   / |3  0  0 |		
	//    			 |---------|0 |
	//			   / | 2  0  0 |0 |
	//			  |---------|0 |__|
	//			  | 1  0  0 |0 | /
	//			  | 0  0  0 |__| 
	//			  | 0  0  0 | /
	//			  |_________|
	int a2[N][M][K] = {
		{ {1} },
		{ {2} },
		{ {3} }
	};//автоматически заполняет 0

	//д)* Инициализация массивов строковыми литералами:
	//Объявите и проинициализируйте строковыми литералами два массива:
	//двухмерный массив и массив указателей. Поясните разницу в использовании
	//элементов таких массивов.
	char a4[][4] = { "ABC", "CBA", "KLJ" };//лишний символ '\0'
	char const* a5[] = { "ABC", "CBA", "KLJ" };
	//1. выделяет память 3*4*sizeof(char) для двухмерного массива и копирует содержимое строковых литералов в соответствующие строки массива
	//2.выделяет память под три указателя для одномерного массива; присваивает каждому элементу массива значение, равное адресу начала
	//соответствующего строкового литерала(направляет каждый элемент массива на соответствующий строковый литерал).


///////////////////////////////////////////////////////////////
//			Динамическое выделение памяти                    //
///////////////////////////////////////////////////////////////
	//Задание2. Создайте динамический двухмерный массив с размерностями,
	//вычисляемыми в процессе выполнения программы - N*M.
	//Задайте значения элементов помощью генератора случайных чисел.
	//Найдите  сумму элементов.
	//Подсказка 1: для генерации случайных чисел используйте функцию
	//стандартной библиотеки - rand() (<cstdlib>)
	//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
	//чисел являются «псевдослучайными», то есть при двух последовательных запусках
	//приложения Вы получаете две одинаковые последовательности значений.
	//Для того чтобы генерируемые "случайные" значения были разными при каждом 
	//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
	//и time() (<ctime>).
	//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
	//Функция time() задает эту точку отсчета, считывая текущее время

	//srand( time( 0 ) );
	{
		srand(time(0));
		int N, M;
		std::cout << "#2 " << std::endl;
		std::cout << "N = ";
		std::cin >> N;
		std::cout << std::endl;
		std::cout << "M = ";
		std::cin >> M;
		std::cout << "size arr:" << N << 'x' << M << ':';
		int** p = new int* [N];
		for (int i = 0; i < N; i++)//231 сстраница
		{
			p[i] = new int[M];
		}
		unsigned int s = 0;
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				p[i][j] = rand() % 100;
				s = s + p[i][j];
			}
		}
		for (int i = 0; i < N; i++)
		{
			std::cout << std::endl;
			for (int j = 0; j < M; j++)
			{
				std::cout << p[i][j] << ' ';
			}
		}
		std::cout << std::endl;
		std::cout << "summa:" << s << std::endl;
		stop


			//Задание2а. В сформированном массиве отсортируйте каждую строку по
			//убыванию значений. Используйте сортировку "выбором"
		{ int buf, max;
			for (int k = 0; k < N; k++) {
				for (int h = 0; h < M - 1; h++) {
					max = h;
					for (int u = h + 1; u < M; u++) {
						if (p[k][u] > p[k][max]) {
							max = u;
						}
					}
					buf = p[k][h];
					p[k][h] = p[k][max];
					p[k][max] = buf;

				}
			}
			for (int i = 0; i < N; i++)
			{
				std::cout << '\n';
				for (int j = 0; j < M; j++)
				{
					std::cout << p[i][j] << ' ';
				}
			}
		}std::cout << std::endl;

		//Задание2б. Объявите одномерный массив размерностью N.
		//Сформируйте значение i-ого элемента одномерного массива  
		//равным среднему значению элементов i-ой строки
		//двухмерного массива
		float* sr = new float[N];
		for (int i = 0; i < N; i++)
		{
			float s = 0;
			int* sum = p[i];
			for (int j = 0; j < M; j++)
			{
				s += *sum;
				sum++;
			}
			sr[i] = s / static_cast<float>(M);
		}
		std::cout << "\nSrednee znachenie:\n";
		for (int i = 0; i < N; i++)
		{
			std::cout << std::fixed;
			std::cout.precision(3);
			std::cout << sr[i] << ' ';
		}

		//Подсказка - не забудьте освободить память!
		for (int i = 0; i < N; i++)
		{
			delete[] p[i];
		}
		delete[] p;
		delete[] sr;
		p = 0; sr = 0;

		std::cout << std::endl;
	}

	/////////////////////////////////////////////////////////////////////
	//Задание 3. а) Напишите фрагмент кода, который вводит NN целых чисел с помощью
	//потока ввода в объявленный Вами встроенный одномерный массив, каждый раз
	//упорядочивая полученное значение по возрастанию
	{
		int N;
		std::cout << "\n#3a\n";
		std::cout << "N = ";
		std::cin >> N;
		int* a = new int[N];
		for (int i = 0; i < N; i++) {
			std::cout << "Insert value:"<<"\n";
			std::cin >> a[i];
			int* ma = a;
			for (int j = 0; j < i; j++) //сортируем то, что уже успело заполниться на данный момент
			{
				int* pmin = ma;
				int* sl = ma + 1;
				for (int k = j + 1; k < i + 1; k++)
				{
					if (*pmin > *sl) pmin = sl;
					sl++;
				}
				int sled = *pmin;
				*pmin = *ma;
				*ma = sled;
				ma++;
			}
		}
		for (int i = 0; i < N; i++)
		{
			std::cout << a[i] << ' ';
		}
		delete[] a;
		a = 0;
		stop;
	}

	//б) Простой поиск.
	//Модифицируйте предыдущее задание следующим образом:очередное значение
	//вводится в массив только при условии, что там еще такого нет (то есть 
	//дубли игнорируются
	{ 
		std::cout << "\n\n#3b\n";
		int N1;
		std::cout << "N1 = ";
		std::cin >> N1;
		int* a1 = new int[N1];
		for (int i = 0; i < N1; i++) {
			std::cout << "Insert value:"<< "\n";
			std::cin >> a1[i];
			int* ma = a1;
			for (int j = 0; j < i; j++)
			{
				int* pmin = ma;
				int* sl = ma + 1;
				for (int k = j + 1; k < i + 1; k++)
				{
					if (*pmin > *sl) pmin = sl;
					sl++;
				}
				int sled = *pmin;
				*pmin = *ma;
				*ma = sled;
				ma++;
			}
		}
		for (int i = 0; i < N1; i++)
		{ if (a1[i]!=a1[i+1])
			std::cout << a1[i] << ' ';
		}
		delete[] a1;
		a1 = 0;
		std::cout << std::endl;
		stop
	}

	///////////////////////////////////////////////////////////////////////////
	//Задание 4*.С помощью данной заготовки напишите программу,
	//которая:
	//вводит строки с клавиатуры с помощью cin>>...
	//в объявленный Вами двухмерный встроенный массив 5*80 элементов типа char;
	//признаком конца ввода является символ * (то есть строка - "*") или
	//заполнение массива (больше свободных строк нет);
	//сортировка строк в алфавитном порядке. Пояснение: крайне
	//не рекомендуется для сортировки сложных объектов физически
	//перемещать их в памяти. Намного эффективнее завести массив
	//указателей на соответствующие строки и перемещать только
	//указатели.
	
	

    //Подсказка: для лексиграфического сравнения строк пользуйтесь
	//функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.
	{	

		//Определите необходимые значения как константы
		const char* STOP_STRING = "*";//признак "прекратить ввод"
		const char M = 80;//максимальный размер одной строки
		const char N = 10;	//максимальное количество строк в массиве
		


		//Объявите двухмерный массив с именем cBuffer типа char и
		// размерностью N*M
		char cBuffer[N][M];

		//Объявите массив (с именем cPointers) указателей на строки
		//размерностью N
		char* cPointers[N];

		//Цикл ввода строк:
		//а) выведите приглашение для ввода
		std::cout << "\n#4" << "\n" << "Insert value: " << "\n";
		//б) пока не введена строка STOP_STRING или не заполнен весь массива
		int ks;
		for (int i = 0; i < N; i++) {


			//ввод строки в массив cBuffer:
			std::cin >> cBuffer[i];

			//если введена строка - признак окончания, то выйти из цикла
			if (strcmp(cBuffer[i], STOP_STRING) == 0) break;
			//Присвойте элементу массива cPointers с индексом nIndex
			//указатель на строку с номером nIndex в массиве cBuffer
			cPointers[i] = cBuffer[i];
			ks = i;//индекс последнего элемента
		}




		//Выдать диагностику о том, что прием строк завершен.
		std::cout << std::endl;
		std::cout << "input ending" << std::endl;


		//Теперь сортируем строки:
		std::cout << "Sorted" << std::endl;
		//Цикл сортировки строк по методу "всплывающего пузырька" в
		//порядке возрастания. На каждой итерации - промежуточная печать 
		//отсортированных строк
		for (int j = 1; j <= ks; j++)
		{
			bool buf = false;
			for (int i = 0; i < ks; i++)
			{
				if (strcmp(cPointers[i], cPointers[i + 1]) == 1)
				{
					swap(cPointers[i], cPointers[i + 1]);
					buf = true;
				}
			}
			for (int k = 0; k <= ks; k++) std::cout << cPointers[k] << std::endl;
			std::cout << std::endl;
			if (buf = false) break; //если перестало сортироваться
		}
		std::cout << "\nfinished work:" << std::endl;
		for (int i = 0; i <= ks; i++) std::cout << cPointers[i] << std::endl;
		
		


	}

	//Задание 5*. Реализуйте задание №4, используя не встроенные,
	//а динамические массивы (массив?). Так как строки могут быть разной длины,
	//эффективным решением было бы отводить под каждую строку ровно столько байтов,
	//сколько требуется для ее хранения.
	//При этом необходимые параметры (количество строк
	//сформируйте с помощью потока ввода
    //Цикл ввода строк:
	{int nStringNumber, kl;
	char el[80];
	const char* stop_str = {"*"};
	bool til = 0;
	std::cout << "\n5.\n" << std::endl;
	std::cout << " Enter the number of lines: ";
	std::cin >> nStringNumber;
	char** cPointers = new char* [nStringNumber]; // выделяется память под массив указателей
	for (int i = 0; i < nStringNumber; i++)
	{
		std::cout << "Enter lines" << std::endl;
		std::cin >> el;
		int Size = 0;//обнулила
		Size = strlen(el) + 1;//1
		cPointers[i] = new char[Size];//под каждую строку ровно столько байтов, сколько требуется для ее хранения
		kl = i;
		if (strcmp(el, stop_str) == 0)
		{
		 til = 1;
		break; // проверка стоп символа 
		}
		strcpy(cPointers[i], el);
	}

	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания кода первого символа
	for (int i = 0; i < kl; i++)
	{
		for (int j = 0; j <= kl- 1; j++)
		{
			if (strcmp(cPointers[j], cPointers[j + 1]) > 0)
			{
				char* tmp = cPointers[j];
				cPointers[j] = cPointers[j + 1];
				cPointers[j + 1] = tmp;
			}
		}
	}
	std::cout << "Sorted line:" << std::endl;
	for (int i = 0; i <= ((til) ? kl - 1 : kl); i++)
	{
		std::cout << " " << cPointers[i] << std::endl;
	}
	std::cout << " " << std::endl;
	//освобождение занятой памяти
	for (int i = 0; i <= kl; i++)
	{
		delete[] cPointers[i];
	}
	delete[] cPointers;
	cPointers = 0;
	}






	//Задание 6*. Объявление и использование указателей на многомерные
	// массивы. Проинициализируйте трехмерный массив
	//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
	//кода, который меняет местами значения элементов четных
	//и нечетных слоев:
	//	было:			     |--------|		
	//  				   / |4  4  4 |		
	//					 |--------|	4 |	
	//				   / |3  3  3 |	4 |	
	//    			 |---------|3 |   |
    //			   / | 2  2  2 |3 | /
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__| 
	//			  | 1  1  1 | /
	//			  |_________|

	//	стало:			     |--------|		
	//  				   / |3  3  3 |		
	//					 |--------|	3 |	
	//				   / |4  4  4 |	3 |	
	//    			 |---------|4 |   |
    //			   / | 1  1  1 |4 | /
	//			  |---------|1 |__|
	//			  | 2  2  2 |1 | /
	//			  | 2  2  2 |__| 
	//			  | 2  2  2 | /
	//			  |_________|
	{ double dArray[4][3][3] = {
	 {{1,1,1},{1,1,1},{1,1,1}},
	 {{2,2,2},{2,2,2},{2,2,2}},
	 {{3,3,3},{3,3,3},{3,3,3}},
	 {{4,4,4},{4,4,4},{4,4,4}}
	};
	for (int i = 0; i < 4; i+=2)
	{
		double(*nc)[3] = dArray[i]; //массив указателей на строки нечетного слоя
		double(*c)[3] = dArray[i + 1];
		for (int j = 0; j < 3; j++)
		{
			for (int k = 0; k < 3; k++)
			{
				swap(nc[j][k], c[j][k]);
			}
		}

		//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
		//... = dArray[i];
		//... = dArray[i + 1];
		//переставляем местами элементы i-того и i+1-ого слоев


	}stop 
	}

	///////////////////////////////////////////////////////////////////////////
	//Задание 7а. Объявите двухмерный встроенный массив элементов типа char.
	//Сформируйте значения элементов массива с помощью генератора случайных 
	//чисел таким образом, чтобы в массиве были только символы '*' и '_'  
	{
		srand(time(0));
		const int X = 10, Y = 6;
		char u[X][Y];
		std::cout << "\n7a\n";

		for (int i = 0; i < X; i++)
		{
			for (int j = 0; j < Y; j++)
			{
				int chet = rand() % 2;
				if (chet == 0) { u[i][j] = '*'; }
				else { u[i][j] = '_'; }
				std::cout << u[i][j] << " ";
			}
			std::cout << std::endl;
		}
		//В каждой строке "сдвиньте звездочки" в начало строки, например:
		//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
		//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
		//и распечатайте массив по строкам - "постройте распределение"

		for (int i = 0; i < X; i++)
		{
			for (int j = 0; j < Y; j++)
			{
				bool end = false;
				for (int k = 0; k < Y - 1; k++)
				{
					if (u[i][k] == '_')
					{
						swap(u[i][k], u[i][k + 1]);
						end = true;
					}
				}
				if (!end) break;

			}
		}
		for (int i = 0; i < X; i++)
		{
			std::cout << std::endl;
			for (int j = 0; j < Y; j++)
			{
				std::cout << u[i][j] << ' ';
			}
		}std::cout << "\n\n\n\n\n";
	}

		// 7б. Модифицируйте предыдущее задание следующим способом:
		//После заполнения массива с помощью генератора случайных чисел
		//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
		//"распределение"
	{

		srand(time(0));
		const int X = 10, Y = 6;
		char u[X][Y];
		char* pu[X];
		std::cout << "7b" << "\n";

		for (int i = 0; i < X; i++)
		{
			for (int j = 0; j < Y; j++)
			{
				int chet = rand() % 2;
				if (chet == 0) { u[i][j] = '*'; }
				else { u[i][j] = '_'; }
				std::cout << u[i][j] << " ";
			}
			std::cout << std::endl;
			pu[i] = u[i];
	    }
		for (int i = 0; i < Y; i++)
		{
			for (int j = 1; j < X; j++)
			{
				bool end = false;
				for (int k = 0; k < X - j; k++) //зачем нам рассматривать элемент, который уже точно всплыл
				{
					if (u[k][i] < u[k + 1][i])
					{
						swap(u[k][i], u[k + 1][i]);
						end = true;
					}
				}
				if (!end) break;

			}
	
		
		}
		for (int i = 0; i < X; i++)
		{
			std::cout << std::endl;
			for (int j = 0; j < Y; j++)
			{
				std::cout << u[i][j] << ' ';
			}
		}
	}
	return 0;
}
